---
title: Java并发02-使用多线程的优缺点及注意问题
author: ifuncat
date: 2021-05-07 20:22:22 +0800
categories: [Java核心]
tags: [Java并发]
---
<style>
img{
    padding-left: 3%;
}
</style>
## 一. 使用多线的优点
### 1. 更高效的利用CPU资源
假设程序从本地读取且处理文件, 从磁盘中读取和处理A文件分别需要5s和2s, 读取和处理B文件分别需要5s和2s. 如果使用同步方式读取和处理A, B文件过程如下:
```bash
5秒读取文件A
2秒处理文件A
5秒读取文件B
2秒处理文件B
---------------------
总共需要14秒
```
从磁盘中读取文件时,CPU大多数时间内在等待磁盘读取数据, 这段时间内CPU非常空闲,它可以做一些别的事情. 通过改变CPU操作顺序就能更好地使用CPU资源.<br/> 
假如采用多线程异步的方式读取和处理A, B文件过程如下:
```bash
5秒读取文件A
5秒读取文件B + 2秒处理文件A
2秒处理文件B
---------------------
总共需要12秒
```
CPU等待A文件被读取完。然后开始读取B文件。当B文件在被读取的时候，CPU会去处理A文件。在等待磁盘读取B文件的时候，CPU大部分时间是空闲的.<br/>
总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多.
### 2. 简化程序设计
在单线程程序中, 如果使用同步方式读取和处理A, B文件, 则必须记录两个文件读取和处理的状态, 即必须等待文件读取完后才能处理, 等待前一个文件处理完后开始下一个文件的读取及处理.<br/>
如果采用异步的方式, 可以启动两个线程, 每个线程处理一个文件的读取及处理. 线程会在等待磁盘读取文件过程中被阻塞. 等待时其他线程能够获得CPU时间片去处理已读取完的文件. <br/>
结果就是, 磁盘总是在繁忙地读取不同的文件到内存, 提高了磁盘和CPU的利用率. 而且每个线程只需要记录一个文件, 因此这种方式更容易编程实现.
```java
@Test
public void testAsynReadHandleFile() throws Exception {
    long start = System.currentTimeMillis();
    Future<Integer> futureA = executor.submit(() -> {
        Thread.sleep(5000);
        System.out.println("读取A文件,耗时5s");
        Thread.sleep(2000);
        System.out.println("处理A文件,耗时2s");
        return Integer.MAX_VALUE; //返回处理结果
    });

    Future<Integer> futureB = executor.submit(() -> {
        Thread.sleep(5000);
        System.out.println("读取B文件,耗时5s");
        Thread.sleep(2000);
        System.out.println("处理B文件,耗时2s");
        return Integer.MAX_VALUE - 1; //返回处理结果
    });

    Integer a = futureA.get();
    Integer b = futureB.get();
    System.out.println("总计耗时: " + (System.currentTimeMillis() - start) / 1000);
}
```
### 3. 程序响应快
设想一个服务端应用, 在某个端口监听进来的请求, 当请求进来时去处理这个请求然后返回结果. 如果一个请求耗时较长, 这段时间内服务端就无法接受新的请求. <br/>
如果采用异步的方式, 监听线程将请求传递给工作者线程, 然后立刻返回监听. 而工作线程则处理请求并返回结果. 这种方式下服务端的监听线程能够迅速返回, 因此更多的客户端能够发送请求给服务端。这个服务也变得响应更快, 即提高了系统的吞吐量.

## 二. 使用多线程的缺点
### 1. 程序设计更为复杂
多线程访问共享数据时, 特别注意共享数据脏读等情况. 复杂场景下线程间的交互往往非常复杂, 例如C线程需要等到A/B两个线程执行完毕后才能执行, 这样A/B/C三个线程间的交互实现起来比较复杂. 
### 2. 多线程上下文切换开销大
当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”).<br/>
CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程. 上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生. 如果活动线程数较大时,多线程的上下文开销大, 影响性能.
### 3. 增加资源消耗
线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程.

## 三. 需要注意的问题
1. 线程的活跃性问题
- 线程死锁问题: 指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞状态.
- 线程饥饿问题: 当存在多个线程时, 可能存在少数一些线程由于优先级低或被阻塞很难获得CPU时间片执行的情况, 可分为以下三种情况:
  - 高优先级线程抢占所有低优先级的线程的CPU时间片;  解决: 设置合理的优先级
  - 线程被永远堵塞在一个等待进入同步块的状态(已进入同步块的线程未释放锁); 解决: 使用锁来代替Synchronized
  - 等待的线程永远不被唤醒; 解决: 使用锁来代替Synchronized
2. 性能问题: 由以上可知, 启动多个线程非常消耗资源, 同时多线程执行时的上下文切换造成CPU性能开销大.
3. 线程的同步安全问题.