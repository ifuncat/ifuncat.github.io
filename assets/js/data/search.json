[ { "title": "Dcoker系列19-部署服务到Swarm集群", "url": "/posts/docker19/", "categories": "Docker", "tags": "Docker", "date": "2021-06-15 23:00:00 +0800", "snippet": "一. 准备工作 搭建Swarm集群, 详见上述教程部分 两manager节点, 两worker节点, 搭建成功如下[root@localhost ~]# docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONj2vnip3q377akcinlit7debtk * localhost.localdomain Ready Active Leader ..." }, { "title": "Dcoker系列18-搭建DockerSwarm集群", "url": "/posts/docker18/", "categories": "Docker", "tags": "Docker", "date": "2021-06-15 20:00:00 +0800", "snippet": "一. 准备工作 VMWare搭建4个CentOS7虚拟机, 处于同一内网中, 每个虚拟机均安装了Docker, 安排如下 此为本地测试所用, 实际情况manager节点的数量必须为基数, 才能满足节点选举. 虚拟机内网IP swarm节点类型 192.168.245.157 manager 192.168.245.167 worker 192.168.245.177 worker 192.168.245.187 ..." }, { "title": "Dcoker系列17-DockerSwarm介绍", "url": "/posts/docker17/", "categories": "Docker", "tags": "Docker", "date": "2021-06-14 23:00:00 +0800", "snippet": "一. 概要 官方文档1. Docker回顾 之前使用的docker run 启动一个容器, docker-compose up 启动一个项目, 即启动一组关联的容器, 这些操作都是基于单机的. 容器都是在一台机器上运行 如果想管理/部署集群服务, 使用docker, docker-compose效率较低2. 什么是Swarm 原生支持Docker集群管理的工具 可以把多个Docker主机组成的系统转换为单一的虚拟Docker主机, 使得容器可以组成跨主机的子网网络 可以把所有集群中所有Docker Engine整合进一个虚拟机Engine的资源池, 通过执行命令与单一的主Sw..." }, { "title": "Dcoker系列16-DockerCompose部署项目", "url": "/posts/docker16/", "categories": "Docker", "tags": "Docker", "date": "2021-06-14 16:00:00 +0800", "snippet": "一. 准备微服务jar 一个非常简单的Springboot构建的web服务, 使用了redis, 每访问一次redis中的值递增 1. 编写源码 项目大致结构&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot..." }, { "title": "Dcoker系列15-DockerCompose介绍", "url": "/posts/docker15/", "categories": "Docker", "tags": "Docker", "date": "2021-06-14 10:20:22 +0800", "snippet": "一. 什么是DockerCompose1. 回顾 开始接触Docker时, 如果安装一个程序, 需要手动拉取镜像, 运行容器. 如果一个服务需要很多关联的服务, 比如一个微服务需要使用MySQL, Redis, MQ等. 这样安装维护起来, 手动操作比较麻烦. 尤其是当微服务采用集群部署, 数据库读写分离, Redis分片集群等, 手动操作难以维护, 效率非常低. 需要一些自动化的操作, 轻松高效地管理容器, 定义运行多个容器2. DockerCompose 介绍 官方文档 DockerCompose作为一个定义和运行多个容器的Docker工具, 使用yaml配置文件来配置服务..." }, { "title": "Docker安装Redis分片集群", "url": "/posts/install01/", "categories": "软件安装", "tags": "软件安装, Docker, Redis", "date": "2021-06-13 09:22:22 +0800", "snippet": "一. Redis的主从, 哨兵, 分片模式的区别https://stor.51cto.com/art/201909/602390.htm二. 部署的Redis分片集群说明 一共六个redis容器, 三个为主(r-master1, r-master2, r-master3 ), 三个为备份(r-slave1, r-slave2, r-slave3) 主服务器向外提供服务, 当主服务器宕机备份服务器立即顶替为主服务器 六个redis容器都处在一个自定义的网络环境下(redis-network)三. 部署过程1. 创建网卡 网段172.38.0.0, ip个数 65533, 网关172..." }, { "title": "Dcoker系列14-Docker网络连通", "url": "/posts/docker14/", "categories": "Docker", "tags": "Docker", "date": "2021-06-12 20:20:22 +0800", "snippet": "1. 回顾 在自定义网络实现docker容器互联中, 发现处在同一网络下的docker容器可以互相访问 使用默认的docker0网络的容器只能根据固定ip进行访问, 而使用自定义网络(如mynet)的容器除了根据固定ip访问外, 还可以根据容器name/id进行访问 但是处于不同网络环境下(确切说不同网段)的容器能否互相连通呢2. 处于不同网络环境下的容器能否互相连通 准备工作 运行使用默认网络docker0的两个容器tomcat01, tomcat02 创建自定义网络mynet 运行使用默认网络docker0的两个容器tomcat-myne..." }, { "title": "Dcoker系列13-自定义网络实现docker容器互联", "url": "/posts/docker13/", "categories": "Docker", "tags": "Docker", "date": "2021-06-11 22:20:22 +0800", "snippet": "一. 问题场景及解决方案1. 场景描述 在Docker网络基本原理中得到, 容器间可以通过docker0桥接, 根据 ip 来进行网络连接, 例如tomcat02访问tomcat01 实际情况中, 微服务的ip可能经常变动, 因此不能根据固定ip来进行访问, 而是根据服务名/服务id来进行访问, 自动映射到对应的ip 如下图中, tomcat01, tomcat02都是使用的默认的docker0网络, 可以通过ip访问, 但是无法通过容器name/id进行访问2. 解决方案 –link 命令: 不推荐 实际上是在目标容器上进行host映射, 类如tomcat02..." }, { "title": "Dcoker系列12-Docker网络模式", "url": "/posts/docker12/", "categories": "Docker", "tags": "Docker", "date": "2021-06-10 21:20:22 +0800", "snippet": "1. 查看所有的docker网络[root@localhost ~]# docker network lsNETWORK ID NAME DRIVER SCOPE7dc0317ebebf bridge bridge local18be96f03c99 host host local99a7589c13f9 none null local[root@localhost ~]#2. docker的网络模式 brige: 桥接, docker默认, 自定义网络推荐使用该模式 none: 不配置网络 ..." }, { "title": "Dcoker系列11-Docker网络基本原理", "url": "/posts/docker11/", "categories": "Docker", "tags": "Docker", "date": "2021-06-08 21:20:22 +0800", "snippet": "一. Docker0网卡 准备工作: 方便初步学习, 清空宿主机上之前存在的docker镜像和容器, 命令如下:docker rm -f $(docker ps -aq) ##先删除所有容器docker rmi -f $(docker images -aq) ##后删除所有镜像 清空完毕后执行 ip addr 命令得到如下结果, 可以看到存在三块网卡: lo : 本机回环地址 127.0.0.1/8 en32 : 本机内网地址 192.168.245.147/24 docker0 : docker默认生成的网卡 172.17.0.1/16 ..." }, { "title": "Dcoker系列10-Docker镜像发布", "url": "/posts/docker10/", "categories": "Docker", "tags": "Docker", "date": "2021-06-06 21:20:22 +0800", "snippet": "一. 发布到DockerHub1. 注册DockerHub账号https://registry.hub.docker.com/2. 宿主机上登录DockerHub账号 假如账户名为 ifuncat## -u 用户名, 执行完后按照提示输入密码docker login -u ifuncat3. 推送镜像到dockerhub上##查看本地都有哪些镜像docker images##推送[root@localhost mytomcat]# docker push ifuncat/centosUsing default tag: latestThe push refers to reposito..." }, { "title": "Dcoker系列09-DockerFile命令及如何构建镜像", "url": "/posts/docker09/", "categories": "Docker", "tags": "Docker", "date": "2021-06-04 21:20:22 +0800", "snippet": "一. 以centos:latest镜像的dockerfile为例详见: https://github.com/CentOS/sig-cloud-instance-images/blob/ccd17799397027acf9ee6d660e75b8fce4c852e8/docker/DockerfileFROM scratchADD centos-8-x86_64.tar.xz /LABEL org.label-schema.schema-version=&quot;1.0&quot; org.label-schema.name=&quot;CentOS Base Image&qu..." }, { "title": "Dcoker系列08-DockerFile简介", "url": "/posts/docker08/", "categories": "Docker", "tags": "Docker", "date": "2021-06-02 21:20:22 +0800", "snippet": "一. DockerFile是什么 用来构建Docker镜像的构建文件, 是由一系列命令和参数构成的脚本 DockerFile构建镜像的过程分为两步: 编写DockerFile文件; 执行docker build生成镜像二. DockerFile 基本内容 每条保留字指令都必须是大写字母, 后面要跟随至少一个参数, 指令与参数间存在一个空格 指令按照从上向下依次执行 每条指令都会创建一个新的镜像层, 并对镜像进行提交三. Docker执行DockerFile脚本的大致流程 docker从基础镜像中启动运行一个容器 执行一条指令并对基础容器做出修改 上一步完成后会创建一个新的..." }, { "title": "Dcoker系列07-多个容器间挂载数据同步", "url": "/posts/docker07/", "categories": "Docker", "tags": "Docker", "date": "2021-05-28 23:20:22 +0800", "snippet": "一. 容器间挂载数据同步需求背景 之前的容器卷/数据卷都是挂载到宿主机上, 但是存在着多个容器之间进行挂载的情况 比如部署mysql集群, 这些mysql要实现多个容器间的数据共享, 满足mysql集群部署要求二. 构建数据卷容器过程1. 运行第一个容器mycentos01 以ifuncat/centos镜像为例, 其中设置了volume01, volume02作为挂载目录, 详见下述文章这的编写dockerFile部分: https://ifuncat.github.io/posts/docker06/## 300e315adb2f: ifuncat/centos镜像id, 启动..." }, { "title": "Dcoker系列06-Docker容器数据卷的使用方式", "url": "/posts/docker06/", "categories": "Docker", "tags": "Docker", "date": "2021-05-26 21:10:22 +0800", "snippet": "一. 按照目录映射方式1. 匿名挂载 没有指定容器数据卷挂载名称, docker默认生成一个随机字符串作为名称 同时也没有指定挂载到宿主机的哪个目录下, docker默认存放的目录为 /var/lib/docker/volumes/随机名/_data##匿名挂载, -v 容器内路径, -P 大写P,随机映射端口docker run -d -P --name nginx02 -v /etc/nginx nginx##查看容器, 查看其中的挂载情况, mounts.source为挂载到宿主机上的源目录, 中间的随机字符串为数据卷的名字docker inspect nginx022. 具名..." }, { "title": "Dcoker系列05-Docker容器数据卷volume介绍", "url": "/posts/docker05/", "categories": "Docker", "tags": "Docker", "date": "2021-05-24 21:20:22 +0800", "snippet": "1. Docker理念及为什么使用容器数据卷 docker的理念即: 将运行环境和应用打包成一个镜像, 以容器的方式运行这个应用 但是对应用中产生的数据希望能做到持久化, 类似Redis持久化机制对应的rdb或aof文件 如果数据都在容器中, 那么当删除容器时, 容器中的数据就会被删除, 如mysql容器删除时, mysql数据库中的数据就会被删除 为了能够持久化容器中的数据, 使用docker容器卷.2. 什么是容器数据卷 用于docker容器的数据持久化技术 通过目录挂载可以经docker容器上的数据挂载到宿主机上, 同时还能实现实时数据同步. 多个容器间也是可以实现数..." }, { "title": "Dcoker系列04-Docker常用命令", "url": "/posts/docker04/", "categories": "Docker", "tags": "Docker", "date": "2021-05-22 22:22:22 +0800", "snippet": "参考命令文档: https://docs.docker.com/engine/reference/commandline/docker/一. 帮助命令docker version ##版本信息docker info ##系统信息,包括镜像和容器的数量docker help ##帮助命令二. 镜像命令https://docs.docker.com/engine/reference/commandline/images/1. docker images 查看所有本地的主机上的镜像docker images ##列出镜像##可选项-a, --all #..." }, { "title": "Dcoker系列03-Docker基本组成及原理", "url": "/posts/docker03/", "categories": "Docker", "tags": "Docker", "date": "2021-05-20 22:22:22 +0800", "snippet": "一. 基本组成1. 镜像(image) docker镜像可以类比为一个模板, 可以通过这个模板来创建多个容器服务 最终服务或项目运行都是在Docker容器中2. 容器(container)  Docker 利用容器独立运行的一个或一组应用. 容器是用镜像创建的运行实例.  它可以被启动、开始、停止、删除. 每个容器都是相互隔离的、保证安全的平台.  可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序.3. 仓库(repository) 仓库（Repository）是集中存放镜像文件的场所. 仓库(Rep..." }, { "title": "Dcoker系列02-centos安装Docker", "url": "/posts/docker02/", "categories": "Docker", "tags": "Docker, 软件安装", "date": "2021-05-18 23:55:22 +0800", "snippet": "一. 准备工作1. 确定CentOS的版本 cat /etc/redhat-release2. 查看内核版本uname -rdocker支持CentOS版本 CentOS 7(64-bit)（系统内核版本为3.10及以上）, CentOS 6.5(64-bit)或更高版本（系统内核版本为 2.6.32-431即以上版本）3. 检查 yum 是否可用yum list4. yum安装gcc相关yum -y install gccyum -y install gcc-c++5. 卸载旧版本(如果有的话)yum remove docker \\ docker-client \\ docker-cl..." }, { "title": "Dcoker系列01-Docker概述", "url": "/posts/docker01/", "categories": "Docker", "tags": "Docker", "date": "2021-05-18 22:22:22 +0800", "snippet": "一. 容器与虚拟机1. 虚拟机 每台虚拟机都需要有自己的操作系统, 虚拟机一旦被开启, 预分配给它的资源将全部被占用 每一台虚拟机包括应用, 必要的二进制文件和库, 以及一个完整的用户操作系统. 常用的传统虚拟机软件如VMWare, VisualBox, ParallelsDesktop2. 容器 容器和宿主机共享硬件资源及操作系统, 可以实现资源的动态分配. 容器包含应用和其所有的依赖包, 但是与其他容器共享内核. 容器在宿主机操作系统中, 运行在用户空间分离的进程中. 容器技术是实现操作系统虚拟化的一种途径, 可以在资源受到隔离的进程中运行应用程序及其依赖关系. 通过使..." }, { "title": "FAQ-ThreadLocal", "url": "/posts/FAQ-threadlocal/", "categories": "经典面试题", "tags": "FAQ, Java并发", "date": "2021-05-14 22:22:22 +0800", "snippet": "xxxxx" }, { "title": "Java并发06-深入理解ThreadLocal", "url": "/posts/java-threadlocal/", "categories": "Java核心", "tags": "Java并发", "date": "2021-05-13 22:22:22 +0800", "snippet": "一. ThreadLocal 概述1. 前言 多线程访问共享变量时容易发生同步问题, 特别是多个线程对共享数据进行写操作的时候. 为了保证线程安全, 在访问共享变量时需要进行额外的同步措施, 如加synchronized锁, volatile修饰共享变量等. ThreadLocal是一种规避多线程同步安全问题的新方法.2. ThreadLocal是什么 ThreadLocal译为线程本地变量(局部变量), 即这个变量是在存在于自身的工作内存中(非共享变量), 不会被其他线程访问到. 每个线程访问ThreadLocal对象时, 访问的都是线程自己的变量, 也就不会产生同步问题.二..." }, { "title": "Java并发05-深入理解Synchronized关键字", "url": "/posts/java-multiThread05/", "categories": "Java核心", "tags": "Java并发", "date": "2021-05-11 22:22:22 +0800", "snippet": "一. 前言 造成线程安全问题主要有三个条件: 多线程环境, 存在共享资源, 多线程对共享资源进行非原子操作. 解决线程安全问题的通常做法是：当存在多个线程操作共享资源时，需要保证同一时刻只有一个线程在操作数据, 其他线程等待这个线程操作完数据，然后再去操作这个更新的数据． 上述解决方案也被称为互斥锁, 当一个共享数据被正在访问的线程加上互斥锁后, 此时其他线程要访问共享数据只能等待, 直到正在访问的线程处理完毕后释放锁, 其他线程竞争这个锁才能访问共享资源. Java的Synchronized关键字可以保证在同一时刻, 只有一个线程可以执行某个方法或代码块(在方法或代码块中操作共..." }, { "title": "Java并发04-线程安全性问题说明", "url": "/posts/java-multiThread04/", "categories": "Java核心", "tags": "Java并发", "date": "2021-05-10 22:22:22 +0800", "snippet": "一. 线程的安全性概述1. 什么是线程的安全性 线程的安全性主要针对线程操作的对象的状态(如对象的实例变量或静态变量)而言的 如果在多线程环境下, 线程操作的对象状态不一致, 那么就是线程不安全的, 例如多线程对变量a进行累加操作, 每个线程读取到的a都是其他线程操作完的最新的值, 执行完后a的值符合预期.2. 产生线程安全性问题的三个条件 多线程环境下不言而喻, 单线程执行不会产生线程安全性问题 存在共享资源 根据定义, 线程安全性问题是针对被操作的对象而言的, 只有多个线程操作共享变量时才可能引起这个变量的状态不一致, 从而产生线程不安全问题. 对共享变量进行非原子性操作线..." }, { "title": "Java并发09-Object.wait/notify/notifyAll方法详解", "url": "/posts/java-multiThread09/", "categories": "Java核心", "tags": "Java并发", "date": "2021-05-09 22:22:22 +0800", "snippet": "一. 概述Java一. Object.wait(): 线程等待1. wait()方法说明 线程在调用wait()时, 会释放当前持有的锁(), 然后让出CPU资源, 线程状态由running-&amp;gt;wating. 只有当别的线程执行notify() / notifyAll(), 才会唤醒一个或多个处于waiting, 然后继续往下执行, 知道执行完synchronized代码块中的代码. 可以通过wait(long), 等待的线程一定时间后自动唤醒. 执行wait()方法时需要被try / catch, 以便发生异常也能使处于等待状态的线程被唤醒2. wait()与sl..." }, { "title": "Java并发08-Thread.join/sleep/yield方法详解", "url": "/posts/java-multiThread8/", "categories": "Java核心", "tags": "Java并发", "date": "2021-05-09 10:22:22 +0800", "snippet": "一. Thread.join(): 线程插队1. join()的理解 源码中的注释: “waits for this thread to die”, 等待这个线程结束 join()方法更形象的说法: 线程插队, 等插队的线程执行完毕, 被插队的才继续执行 举例说明: 程序中有两个线程t1, t2, t1的run()方法中调用了t2.join(), 则t1线程会在此段代码t2.join()执行后退出, 即暂停t1的run()方法中t2.join()这段代码的下面的代码, 直到t2线程执行完毕后, t1线程才会执行后续的未完代码.2.join()的使用示例场景 程序中有两线程t1, ..." }, { "title": "Java并发03-守护线程/线程的中断", "url": "/posts/java-multiThread03/", "categories": "Java核心", "tags": "Java并发", "date": "2021-05-09 10:22:22 +0800", "snippet": "一. 守护线程1. 什么是守护线程 简单来说就是为其他线程服务的线程. 也可以称之为后台线程, 非用户线程, 即随系统结束而结束的线程. JVM中, 所有非守护线程都执行完毕后, 无论是否存在守护线程, JVM都会自动退出 编写代码时注意: 守护线程不能持有任何需要关闭的资源, 如IO流等, 因为JVM退出时, 守护线程没有机会来释放资源, 会导致数据丢失.2. 代码演示@Testpublic void testDaemon(){ Thread t1 = new Thread(() -&amp;gt; { try { Thread.sle..." }, { "title": "开发Tips02-AOP+注解实现日志打印方法入参返回值", "url": "/posts/devTips02-methodLogAspect/", "categories": "开发Tips", "tags": "开发Tips, 日志优化, AOP", "date": "2021-05-08 22:22:22 +0800", "snippet": "概述利用SpringAOP+自定义注解实现打印方法的入参和返回值, 避免在方法前后编写重复的输出日志代码.实现过程介绍实现过程主要分为两步:1. 自定义以下两个个注解 @MethodLog可以用于方法或类上, 用在方法上表明需要对该方法打印入参和返回结果, 用在类上表明需要对该类下的所有public方法打印入参和返回结果.有一个属性httpInfoFlag, 默认false, 即日志中不打印http方法信息, true则相反. @MethodLogIgnore用于方法, 用在方法上表明无需对该方法打印入参和返回结果.如果使用了@MethodLog类的某个方法不想打印入参和返回结果, ..." }, { "title": "开发Tips01-日志添加traceId从而快速定位方法调用链", "url": "/posts/devTips01-log+traceId/", "categories": "开发Tips", "tags": "开发Tips, 日志优化", "date": "2021-05-08 20:22:22 +0800", "snippet": "问题场景描述 一般情况下,通过日志排查问题时,需要确定方法的调用链, 并发低时同一调用链路上的日志往往相隔在一起, 结合关键词容易找到目标日志信息. 如果并发比较高, 多个线程对应的调用链路的日志会糅杂在一起, 给寻找目标日志带来麻烦解决思路如果给同一调用链路上的每条日志加上同一唯一的traceId, 那么通过这个traceId就能迅速定位整个调用链路上的所有日志, traceId+关键词就会快速找到目标日志信息.实现方案Springboot默认日志facade为slfj2, 利用slfj2.mdc(Mapped Diagnostic Context)机制为日志增加traceId, ..." }, { "title": "Java并发02-使用多线程的优缺点及注意问题", "url": "/posts/java-multiThread02/", "categories": "Java核心", "tags": "Java并发", "date": "2021-05-07 20:22:22 +0800", "snippet": "一. 使用多线的优点1. 更高效的利用CPU资源假设程序从本地读取且处理文件, 从磁盘中读取和处理A文件分别需要5s和2s, 读取和处理B文件分别需要5s和2s. 如果使用同步方式读取和处理A, B文件过程如下:5秒读取文件A2秒处理文件A5秒读取文件B2秒处理文件B---------------------总共需要14秒从磁盘中读取文件时,CPU大多数时间内在等待磁盘读取数据, 这段时间内CPU非常空闲,它可以做一些别的事情. 通过改变CPU操作顺序就能更好地使用CPU资源. 假如采用多线程异步的方式读取和处理A, B文件过程如下:5秒读取文件A5秒读取文件B + 2秒处理文件A2秒处..." }, { "title": "Java并发01-进程与线程/线程生命周期/创建线程的几种方式", "url": "/posts/java-multiThread01/", "categories": "Java核心", "tags": "Java并发", "date": "2021-05-06 20:22:22 +0800", "snippet": "一. 进程与线程1. 进程(Process)的基本概念 指一个内存中运行的应用程序, 每个进程都有一个独立的内存空间, 程序进入内存后就称为进程. 一个应用程序可以同时运行多个进程, 进程也是程序的一次执行过程, 是系统运行程序的基本单位. 系统运行一个程序即为从一个进程创建, 运行到死亡的过程.2. 线程的基本概念(Thread) 线程是进程中的一个执行单元, 负责当前进程中程序的执行. 一个程序至少有一个进程, 一个进程至少由一个线程. 3. 线程工作内存与进程内存(主内存) Java内存模型规定, 所有变量都存储在主内存中, 每个线程中有自己的工作内存..." }, { "title": "Win10安装ruby+jekyll", "url": "/posts/win10-install-ruby+jekyll/", "categories": "软件安装", "tags": "软件安装", "date": "2021-04-29 22:22:22 +0800", "snippet": "1.安装ruby 下载ruby+devkit2.7.3-1(x64) 注意不要下载3.x版本, 64位, 下载链接: https://rubyinstaller.org/downloads/ 安装.exe文件 注意以下几点 建议安装在C盘以外的目录, 不要把路径设置有空格、中文、特殊符号 不要取消勾选, 一路选择下一步即可, 安装程序会自动帮助建立ruby的环境变量, 无需自己配置 最后一步要勾选 run ‘ridk install’ to setup MSYS2, 并且安装全部三个组件 执行 ruby ..." } ]
